using CanTraceConverter.Models;
using Microsoft.VisualBasic;
using System.Globalization;
using System.Text.RegularExpressions;

namespace CanTraceConverter.Extensions
{
    public class TraceExtensions
    {
        public static bool IsValidTrace(string filePath)
        {
            if (!File.Exists(filePath))
                return false;

            List<string> strings = new List<string>();
            try
            {
                strings = new List<string>(File.ReadAllLines(filePath));
            }
            catch
            {

            }
            List<string> retVal = new List<string>();
            TraceType traceType = GetTraceType(strings);
            if (traceType == TraceType.TraceType_Unknown)
                return false;
            else
                return true;
        }
        public static List<string> GenVectorTrace(List<CanMessage> msgs, DateTime startTime)
        {
            List<string> retVal = new List<string>();
            string formattedTime = startTime.ToString("ddd MMM dd hh:mm:ss.fff tt yyyy");
            //uint timeStamp = 0;
            string IdStrHex;
            string IdStrDec;

            retVal.Add($"date {formattedTime}");
            retVal.Add("base hex  timestamps absolute");
            retVal.Add("internal events logged");
            retVal.Add("// version 17.0.0");

            foreach (CanMessage msg in msgs)
            {
                uint timeStamp = msg.TimeStamp;
                double timestampSeconds = timeStamp / 1000000.0; // 将时间戳转换为秒
                string timestampString = timestampSeconds.ToString("0.000000");
                if (msg.ID > 0x7FF)
                {
                    IdStrHex = $"{msg.ID:X}x";
                    IdStrDec = $"{msg.ID}x";
                }
                else
                {
                    IdStrHex = $"{msg.ID:X}";
                    IdStrDec = $"{msg.ID}";
                }
                string Currline = $"{timestampString.PadLeft(11)} 1  {IdStrHex.PadRight(16)}{msg.Dir}   d {msg.LEN} ";
                foreach (byte data in msg.DATA)
                {
                    if (data != null)
                    {
                        Currline += $" {data:X2}";
                    }
                }
                Currline += $" ID = {IdStrDec}";
                retVal.Add(Currline);
            }
            return retVal;
        }

        public static List<string> GenPcanTrace(List<CanMessage> msgs, DateTime startTime)
        {
            List<string> retVal = new List<string>();
            uint lineNumber = 1;
            string IdStrHex;
            string IdStrDec;
            string formattedTime = startTime.ToString("MM/dd/yyyy HH:mm:ss.fff.0");
            retVal.Add(";$FILEVERSION=1.1");
            // Excel 的起始日期是 1900-01-01
            retVal.Add($";$STARTTIME=45631.6687381366");
            retVal.Add(";");
            retVal.Add($";   Start time: {formattedTime}");
            retVal.Add(";   Generated by PCAN-View v5.3.0.942");
            retVal.Add(";");
            retVal.Add(";   Message Number");
            retVal.Add(";   |         Time Offset (ms)");
            retVal.Add(";   |         |        Type");
            retVal.Add(";   |         |        |        ID (hex)");
            retVal.Add(";   |         |        |        |     Data Length");
            retVal.Add(";   |         |        |        |     |   Data Bytes (hex) ...");
            retVal.Add(";   |         |        |        |     |   |");
            retVal.Add(";---+--   ----+----  --+--  ----+---  +  -+ -- -- -- -- -- -- --");
            foreach (CanMessage msg in msgs)
            {
                double timestampSeconds = msg.TimeStamp / 1000.0; // 将时间戳转换为ms
                string timestampString = timestampSeconds.ToString("0.0");
                if (msg.ID > 0x7FF)
                {
                    IdStrHex = $"{msg.ID:X}";
                    IdStrDec = $"{msg.ID}";
                }
                else
                {
                    IdStrHex = $"{msg.ID:X}";
                    IdStrDec = $"{msg.ID}";
                }
                string lineString = lineNumber.ToString() + ")";
                string Currline = $" {lineString.PadLeft(6)}   " +
                                    $"{timestampString.PadLeft(9)}  {msg.Dir.PadRight(5)}  {IdStrHex.PadLeft(8)}  {msg.LEN}  ";
                for (int i = 0; i < msg.LEN; i++)
                {
                    Currline += $"{msg.DATA[i]:X2} ";
                }
                retVal.Add(Currline);
                lineNumber++;
            }
            return retVal;
        }

        public static void SaveTraceFile(string filePath, List<string> content)
        {
            string directory = Path.GetDirectoryName(filePath);

            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
            File.WriteAllLines(filePath, content);
        }
        public static string GetTimeStringFromTrace(List<string> content, TraceType traceType)
        {
            const string Pcan_absStartTime = "$STARTTIME";
            const string Pcan_StartTime = "Start time";
            const string VectorTime = "date";
            var retVal = string.Empty;
            switch (traceType)
            {
                case TraceType.TraceType_Vector:
                    foreach (string line in content)
                    {
                        string result = ExtractAfterRegex(line, VectorTime, true);
                        if (!string.IsNullOrEmpty(result))
                        {
                            return result;
                        }
                    }
                    break;
                case TraceType.TraceType_Pcan:
                    foreach (string line in content)
                    {
                        string result = ExtractAfterRegex(line, Pcan_StartTime, true);
                        if (!string.IsNullOrEmpty(result))
                        {
                            return ProcessTimeString(result.Substring(1));
                        }
                    }
                    break;
            }
            return retVal;
        }
        public static string ProcessTimeString(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            int firstDotIndex = input.IndexOf('.');
            if (firstDotIndex == -1)
                return input;

            int secondDotIndex = input.IndexOf('.', firstDotIndex + 1);
            if (secondDotIndex == -1)
                return input;

            return input.Substring(0, secondDotIndex);
        }
        public static string ExtractAfterRegex(string line, string pattern, bool ignoreCase = true)
        {
            RegexOptions options = ignoreCase ? RegexOptions.IgnoreCase : RegexOptions.None;

            var match = Regex.Match(line, pattern, options);
            if (!match.Success)
                return string.Empty;

            int endIndex = match.Index + match.Length;
            return line.Substring(endIndex).Trim();
        }
        public static DateTime ConvertToTimeFromString(string content)
        {
            if (string.IsNullOrEmpty(content))
                return DateTime.Now;

            string[] formats = new[]
            {
                    "dddd M月 dd HH:mm:ss yyyy",
                    "dddd M月 dd HH:mm:ss tt yyyy",
                    "ddd MMM dd hh:mm:ss.fff tt yyyy",
                    "ddd MMM d hh:mm:ss.fff tt yyyy",
                    "ddd MMM dd HH:mm:ss yyyy"  ,            
                    //PCAN date
                     "yyyy'/'M'/'d HH:mm:ss.fff",
                    "yyyy'/'M'/'d HH:mm:ss.ffffff",
                    "yyyy'/'MM'/'dd HH:mm:ss.ffffff",
            };
            CultureInfo[] cultureInfos = new[]
            {
                CultureInfo.GetCultureInfo("en-US"),
                CultureInfo.GetCultureInfo("zh-CN"),
                CultureInfo.GetCultureInfo("de"),
                CultureInfo.GetCultureInfo("ko"),
                CultureInfo.GetCultureInfo("jp"),
            };
            foreach (var culture in cultureInfos)
            {
                if (DateTime.TryParseExact(
                        content.Trim(),
                        formats,
                        culture,
                        DateTimeStyles.None,
                        out var result))
                {
                    return result;
                }
            }
            return DateTime.Now;
        }
        public static TraceType GetTraceType(List<string> content)
        {
            const string KeyWordPcan_1 = "FILEVERSION";
            const string KeyWordPcan_2 = "STARTTIME";
            const string KeyWordPcan_3 = "Generated by";
            const string KeyWordPcan_4 = "Start time";
            const string KeyWordVector_1 = "date";
            const string KeyWordVector_2 = "base hex";
            const string KeyWordVector_3 = "timestamps absolute";
            const string KeyWordVector_4 = "internal events logged";
            int PcanCounter = -1;
            int VectorCounter = -1;
            foreach (string line in content.Take(20))
            {
                if (line.IndexOf(KeyWordPcan_1, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    PcanCounter++;
                }
                //if (line.Contains(KeyWordPcan_1, StringComparison.OrdinalIgnoreCase))
                //{
                //    PcanCounter++;
                //}

                if (line.IndexOf(KeyWordPcan_2, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    PcanCounter++;
                }
                //if (line.Contains(KeyWordPcan_2, StringComparison.OrdinalIgnoreCase))
                //{
                //    PcanCounter++;
                //}
                if (line.IndexOf(KeyWordPcan_3, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    PcanCounter++;
                }
                //if (line.Contains(KeyWordPcan_3, StringComparison.OrdinalIgnoreCase))
                //{
                //    PcanCounter++;
                //}
                if(line.IndexOf(KeyWordPcan_4, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    PcanCounter++;
                }
                //if (line.Contains(KeyWordPcan_4, StringComparison.OrdinalIgnoreCase))
                //{
                //    PcanCounter++;
                //}
                if(line.IndexOf(KeyWordVector_1, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    VectorCounter++;
                }
                //if (line.Contains(KeyWordVector_1, StringComparison.OrdinalIgnoreCase))
                //{
                //    VectorCounter++;
                //}
                if(line.IndexOf(KeyWordVector_2, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    VectorCounter++;
                }
                //if (line.Contains(KeyWordVector_2, StringComparison.OrdinalIgnoreCase))
                //{
                //    VectorCounter++;
                //}
                if(line.IndexOf(KeyWordVector_3, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    VectorCounter++;
                }
                //if (line.Contains(KeyWordVector_3, StringComparison.OrdinalIgnoreCase))
                //{
                //    VectorCounter++;
                //}
                if(line.IndexOf(KeyWordVector_4, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    VectorCounter++;
                }
                //if (line.Contains(KeyWordVector_4, StringComparison.OrdinalIgnoreCase))
                //{
                //    VectorCounter++;
                //}
            }
            if (PcanCounter > VectorCounter && PcanCounter > 0)
            {
                return TraceType.TraceType_Pcan;
            }
            else if (PcanCounter < VectorCounter && VectorCounter > 0)
            {
                return TraceType.TraceType_Vector;
            }
            else
            {
                return TraceType.TraceType_Unknown;
            }
        }

        public static string GetPcanTraceFileVersion(List<string> strings)
        {
            foreach (string line in strings)
            {
                if(line.IndexOf("FILEVERSION", StringComparison.OrdinalIgnoreCase) >= 0 )
                {
                    string[] strings1 = line.Split('=');
                    return strings1.Last();
                }
                //if (line.Contains("FILEVERSION", StringComparison.OrdinalIgnoreCase))
                //{
                //    string[] strings1 = line.Split("=");
                //    return strings1.Last();
                //}
            }
            return string.Empty;
        }

        public static IDictionary<string, int> GetPcanTraceColumnIndex(List<string> strings)
        {
            IDictionary<string, int> dictionary = new Dictionary<string, int>();
            string version = GetPcanTraceFileVersion(strings);

            if (version == "1.0")
            {
                dictionary.Add("Time", 1);
                dictionary.Add("Type", -1);
                dictionary.Add("Id", 2);
                dictionary.Add("Len", 3);
                dictionary.Add("Data", 4);
            }
            if (version == "1.1")
            {
                dictionary.Add("Time", 1);
                dictionary.Add("Type", 2);
                dictionary.Add("Id", 3);
                dictionary.Add("Len", 4);
                dictionary.Add("Data", 5);
            }
            else if (version == "1.2")
            {
                dictionary.Add("Time", 1);
                dictionary.Add("Type", 3);
                dictionary.Add("Id", 4);
                dictionary.Add("Len", 5);
                dictionary.Add("Data", 6);
            }
            else if (version == "1.3")
            {
                dictionary.Add("Time", 1);
                dictionary.Add("Type", 3);
                dictionary.Add("Id", 4);
                dictionary.Add("Len", 6);
                dictionary.Add("Data", 7);
            }
            else if (version == "2.0" || version == "2.1")
            {
                List<string> list = GetPcanColumnName(strings);

                for (int i = 0; i < list.Count; i++)
                {
                    if (list[i] == "O")
                    {
                        dictionary.Add("Time", i);
                    }
                    else if (list[i] == "I")
                    {
                        dictionary.Add("Id", i);
                    }
                    else if (list[i] == "d")
                    {
                        dictionary.Add("Type", i);
                    }
                    else if (list[i] == "l")
                    {
                        dictionary.Add("Len", i);
                    }
                    else if (list[i] == "D")
                    {
                        dictionary.Add("Data", i);
                    }
                }
            }
            return dictionary;
        }
        public static List<string> GetPcanColumnName(List<string> strings)
        {
            List<string> retVal = new List<string>();
            foreach (string line in strings)
            {
                if (line.IndexOf("COLUMNS", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    string[] columnstrings = line.Split('=');
                    string[] columnName = columnstrings[1].Split(',');
                    foreach (string name in columnName)
                    {
                        retVal.Add(name);
                    }
                }
            }
            return retVal;
        }
        public static CanMessage GetMessageFromPcanString(string lineString)
        {
            CanMessage retVal = new();
            string[] words = lineString.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (words.Length >= 6)
            {
                // PCAN-VIEW
                if (string.Equals(words[2], "Tx", StringComparison.OrdinalIgnoreCase)
                    || string.Equals(words[2], "Rx", StringComparison.OrdinalIgnoreCase))

                {
                    retVal.ID = uint.Parse(words[3], System.Globalization.NumberStyles.HexNumber);
                    retVal.LEN = ushort.Parse(words[4]);
                    retVal.Dir = words[2];
                    retVal.TimeStamp = (uint)double.Parse(words[1]);
                    retVal.DATA = new byte[retVal.LEN];
                    for (int i = 0; i < retVal.LEN; i++)
                    {
                        retVal.DATA[i] = byte.Parse(words[5 + i], System.Globalization.NumberStyles.HexNumber);
                    }
                }
                // PCAN-EXPLORER
                else if (string.Equals(words[3], "Tx", StringComparison.OrdinalIgnoreCase)
                    || string.Equals(words[3], "Rx", StringComparison.OrdinalIgnoreCase))
                {
                    retVal.ID = uint.Parse(words[4], System.Globalization.NumberStyles.HexNumber);
                    retVal.LEN = ushort.Parse(words[6]);
                    retVal.Dir = words[3];
                    retVal.TimeStamp = (uint)double.Parse(words[1]);
                    retVal.DATA = new byte[retVal.LEN];
                    for (int i = 0; i < retVal.LEN; i++)
                    {
                        retVal.DATA[i] = byte.Parse(words[7 + i], System.Globalization.NumberStyles.HexNumber);
                    }
                }
            }
            return retVal;
        }
        private static bool GetPcanTraceTimeIndex(IDictionary<string, int> dictionary, out int timeIndex)
        {
            timeIndex = -1;
            return dictionary.TryGetValue("Time", out timeIndex);
        }
        private static bool GetPcanTraceDirIndex(IDictionary<string, int> dictionary, out int DirIndex)
        {
            DirIndex = -1;
            return dictionary.TryGetValue("Type", out DirIndex);
        }
        private static bool GetPcanTraceLenIndex(IDictionary<string, int> dictionary, out int LenIndex)
        {
            LenIndex = -1;
            return dictionary.TryGetValue("Len", out LenIndex);
        }
        private static bool GetPcanTraceDataIndex(IDictionary<string, int> dictionary, out int DataIndex)
        {
            DataIndex = -1;
            return dictionary.TryGetValue("Data", out DataIndex);
        }
        private static bool GetPcanTraceIdIndex(IDictionary<string, int> dictionary, out int IdIndex)
        {
            IdIndex = -1;
            return dictionary.TryGetValue("Id", out IdIndex);
        }
        public static CanMessage GetMessageFromPcanString(string lineString, int timeIndex, int idIndex, int dirIndex, int lenIndex, int dataIndex)
        {
            CanMessage retVal = new();
            if (lineString.StartsWith(";"))
                return retVal;

            if (timeIndex < 0 || idIndex < 0 || lenIndex < 0 || dataIndex < 0)
            {
                return retVal;
            }
            string[] words = lineString.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

            if (dirIndex > 0)
            {
                if (string.Equals(words[dirIndex], "Tx", StringComparison.OrdinalIgnoreCase)
                || string.Equals(words[dirIndex], "Rx", StringComparison.OrdinalIgnoreCase))

                {
                    retVal.ID = uint.Parse(words[idIndex], NumberStyles.HexNumber);
                    retVal.LEN = ushort.Parse(words[lenIndex]);
                    retVal.Dir = words[dirIndex];
                    retVal.TimeStamp = (uint)(double.Parse(words[timeIndex]) * 1000);
                    retVal.DATA = new byte[retVal.LEN];
                    for (int i = 0; i < retVal.LEN; i++)
                    {
                        retVal.DATA[i] = byte.Parse(words[dataIndex + i], NumberStyles.HexNumber);
                    }
                }
            }
            else
            {
                retVal.ID = uint.Parse(words[idIndex], NumberStyles.HexNumber);
                retVal.LEN = ushort.Parse(words[lenIndex]);
                retVal.Dir = "Rx";
                retVal.TimeStamp = (uint)(double.Parse(words[timeIndex]) * 1000);
                retVal.DATA = new byte[retVal.LEN];
                for (int i = 0; i < retVal.LEN; i++)
                {
                    retVal.DATA[i] = byte.Parse(words[dataIndex + i], NumberStyles.HexNumber);
                }
            }
            return retVal;
        }
        public static CanMessage GetMessageFromVectorString(string lineString)
        {
            CanMessage retVal = new();
            string[] words = lineString.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (words.Length >= 6)
            {
                if (string.Equals(words[3], "Tx", StringComparison.OrdinalIgnoreCase)
                    || string.Equals(words[3], "Rx", StringComparison.OrdinalIgnoreCase))
                {
                    //retVal.ID = uint.Parse(words[2].Replace("x", "", StringComparison.OrdinalIgnoreCase), System.Globalization.NumberStyles.HexNumber);
                    retVal.ID = uint.Parse(words[2].Replace("x", "").Replace("X", ""), NumberStyles.HexNumber);
                    retVal.LEN = ushort.Parse(words[5]);
                    retVal.Dir = words[3];
                    retVal.TimeStamp = (uint)(double.Parse(words[0]) * 1000000.0);
                    retVal.DATA = new byte[retVal.LEN];
                    for (int i = 0; i < retVal.LEN; i++)
                    {
                        retVal.DATA[i] = byte.Parse(words[6 + i], NumberStyles.HexNumber);
                    }
                }
            }
            return retVal;

        }

        public static List<string> GenMessagesContent(List<CanMessage> messages, TraceType traceType, DateTime startTime)
        {
            var retVal = new List<string>();
            if (messages.Count > 0)
            {
                switch (traceType)
                {
                    case TraceType.TraceType_Unknown:
                        return retVal;
                    case TraceType.TraceType_Vector:
                        retVal = GenVectorTrace(messages, startTime);
                        break;
                    case TraceType.TraceType_Pcan:
                        retVal = GenPcanTrace(messages, startTime);
                        break;
                }
            }
            return retVal;
        }
        public static List<CanMessage> ParsingCanMessages(string filePath, List<uint> includeIds, List<uint> excludeIds)
        {
            var retVal = new List<CanMessage>();
            List<string> strings = new List<string>();
            try
            {
                strings = new List<string>(File.ReadAllLines(filePath));
            }
            catch
            {
                return retVal;
            }

            TraceType traceType = GetTraceType(strings);

            CanMessage tempMsg = new();
            switch (traceType)
            {
                case TraceType.TraceType_Vector:
                    foreach (string line in strings)
                    {
                        tempMsg = GetMessageFromVectorString(line);
                        if (tempMsg.DATA != null)
                        {
                            retVal.Add(tempMsg);
                        }
                    }
                    break;
                case TraceType.TraceType_Pcan:
                    IDictionary<string, int> dictionary = GetPcanTraceColumnIndex(strings);
                    GetPcanTraceTimeIndex(dictionary, out int timeIndex);
                    GetPcanTraceIdIndex(dictionary, out int idIndex);
                    GetPcanTraceLenIndex(dictionary, out int lenIndex);
                    GetPcanTraceDirIndex(dictionary, out int dirIndex);
                    GetPcanTraceDataIndex(dictionary, out int dataIndex);
                    foreach (string line in strings)
                    {
                        tempMsg = GetMessageFromPcanString(line, timeIndex, idIndex, dirIndex, lenIndex, dataIndex);
                        if (tempMsg.DATA != null)
                        {
                            retVal.Add(tempMsg);
                        }
                    }
                    break;
            }
            // Filter
            List<CanMessage> filteredMessages = new();

            if (includeIds?.Count > 0)
            {
                //  includeIds  
                filteredMessages = retVal.Where(m => includeIds.Contains(m.ID)).ToList();
            }
            else if (excludeIds?.Count > 0)
            {
                //  excludeIds 
                filteredMessages = retVal.Where(m => !excludeIds.Contains(m.ID)).ToList();
            }
            else
            {
                // No Filter
                filteredMessages = retVal;
            }
            return filteredMessages;
        }
    }
}
